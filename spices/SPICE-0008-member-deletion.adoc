= Member deletion

* Proposal: link:./SPICE-0008-member-deletion.adoc[SPICE-0008]
* Status: TBD
* Implemented in: Pkl 0.27 ()
* Category: Language

== Introduction

The deletion of object members (properties in ``Dynamic``s, elements, or entries) currently typically requires transforming objects to programming-optimized APIs (for example, `toMap()`), deleting the member, and transforming back.
This SPICE introduces keyword `delete`, which allows the deletion of an object member from an object "directly," i.e. without such transformations.
This proposal _only_ concerns the core language and has no implications for language bindings or other integrations.

== Motivation

[NOTE]
====
The examples in this proposal focus on ``Dynamic``s, because they are the only object type that can simultaneously contain properties, entries, and elements, making them the most complicated case impacted by this proposal.
No further emphasis of ``Dynamic``s over ``Listing``s or ``Mapping``s is to be derived from this focus.
Indeed, ``Listing``s and ``Mapping``s are the foreseen predominant use-cases for this proposal.
====

When amending a module that contains ``Dynamic``s, ``Listing``s, and/or ``Mapping``s, changing or adding members (properties, elements, or entries) in those is straightforward.
For example, consider `base.pkl` containing the following definition.

[source,pkl]
----
prop: Dynamic = new {
  foo = this["bar"] // <1>
  42 // <2>
  bar = false // <3>
  ["bar"] = "baz" // <3>
}
----
<1> Property referring to entry `"bar"`
<2> `Number` valued element
<3> Property and entry with the same name, respectively key.

Now consider `amending.pkl` defined as follows.

[source,pkl]
----
amends "base.pkl"

prop {
  [0] = super[0] - 14 // <1>
  496 // <2>
  ["qux"] = bar // <3>
  quux = false // <4>
}
----
<1> Amending an existing element
<2> Adding a new element
<3> Adding a new entry referring to property `bar`
<4> Adding a new property

Evaluating `amending.pkl` renders the following result.

[source,pkl]
----
prop {
  foo = "baz"
  bar = false
  ["bar"] = "baz"
  28
  quux = false
  ["qux"] = false
  496
}
----

Amending existing members or adding new ones is straightforward.
Deleting members, however, is not.
If, in the above example, the entry `"baz"` should be deleted, there is no "direct" way of doing so.
Instead, `prop` would first need to be converted to a `Map`, then `"baz"` would be removed, and finally the resulting `Map` would be converted back to a `Dynamic`;

[source,pkl]
----
amends "base.pkl"

prop = (super.prop.toMap().remove("foo").toDynamic()) {
  [0] = super[0] - 14 // <1>
  496
  ["qux"] = bar
  quux = false
}
----
<1> No longer amends anything (see below)

Evaluating this adjusted `amending.pkl` renders the following result.

[source,pkl]
----
prop { // <1>
  bar = "baz" // <2>
  quux = false
  496
  ["qux"] = "baz" // <2>
}
----
<1> There is no more element `28`.
<2> Entry `"bar"` has been transformed into property `bar`, the original `bar` property has been discarded, and entry `"qux"` now refers to the new `bar` property.

Besides being cumbersome, this method has multiple additional issues:

1. When a `Dynamic` has a property with the same name as a `String`-keyed entry, `toMap()` retains the entry and drops the property.
2. Regardless of overlap, when transforming back `toDynamic()`, all members that were previously _properties_ or _entries_ now become _properties_.
3. Members defined lazily, in terms of other members, lose this late-bound relationship, because `toMap()` forces the evaluation of all properties and entries to _values_ (instead of late-bound expressions).
4. Changing to and from a `Map` discards the existing order of the object members; the _properties_ in `super.prop` are grouped at the start, followed by the _entries_ of `super.prop`.
5. This approach discards all _elements_ in `super.prop`.

That last point about the loss of elements is not easily worked around and has some further consequences.
The object member `[0] = super[0] - 14` no longer has an existing element to amend, so it is ignored entirely.
Explicitly spreading the elements of `super.prop` into this new `Dynamic` would cause this expression to trigger a ``Duplicate definition of member `0``` error.

``Listing``s and ``Mapping``s only have _elements_, respectively, _entries_, whose order is preserved when transformed `toList()`, respectively, `toMap()`, so they only suffer from issue 3 and the cumbersome formulation.

== Proposed Solution

A new keyword, `delete`, is introduced to the language.
This keyword can be used in the expression position of an assignment-style object member specification.

With this new keyword, `amending.pkl` from the <<Motivation>> can be reformulated as follows.

[source,pkl]
----
amends "base.pkl"

prop {
  [0] = super[0] - 14
  496
  ["quux"] = foo
  ["baz"] = delete // <1>
  grault = false
}
----
<1> "Assigning" `delete` to the entry `"baz"` removes it from `prop`.

The intended evaluation result is the following.

[source,pkl]
----
prop {
  bar = false
  ["bar"] = "baz"
  28
  quux = false
  ["qux"] = false
  496
}
----

This solution provides improved ergonomics, keeps entries and properties separate, and preserves late-boundness, member order, and elements.

Note, that trying to `delete` a property from a `Typed` object constitutes an error.

== Detailed design

The solution changes the grammar as follows:

- `delete` is promoted from a `reservedKeyword` to a lexer token.
- The grammar rule for `objectMember` is changed by adding `'delete'` as an alternative to `expr` in the `objectProperty`, `memberPredicate`, and `objectEntry` clauses, as shown below.
In the `objectProperty` case, `modifier*` must be empty.

[source,antlr]
----
objectMember
  : modifier* Identifier (typeAnnotation? '=' (expr | 'delete') | objectBody+)  # objectProperty
  | methodHeader '=' expr                                                       # objectMethod
  | t='[[' k=expr err1=']'? err2=']'? ('=' v=(expr | 'delete') | objectBody+)   # memberPredicate
  | t='[' k=expr err1=']'? err2=']'? ('=' v=(expr | 'delete') | objectBody+)    # objectEntry
  | expr                                                                        # objectElement
  | ('...' | '...?') expr                                                       # objectSpread
  | 'when' '(' e=expr err=')'? (b1=objectBody ('else' b2=objectBody)?)          # whenGenerator
  | 'for' '(' t1=parameter (',' t2=parameter)? 'in' e=expr err=')'? objectBody  # forGenerator
  ;
----

For the interpreter, resolving properties or entries requires a traversal of the prototype chain.
When the first occurrence of a member in the prototype chain is marked `delete`, resolution concludes said member does not exist.

Deletion has implications for indices of elements.
When an element is deleted, all consecutive elements shift forward.
In other words, when deleting element `i` any element at index `j` (where `j` > `i`) moves to index `j - 1`.
This affects any hard-coded index-based references.
Consider the following example.

[source,pkl]
----
original = new {
  "foo"
  false
  this[0]
}

amended = (original) {
  [0] = delete
}
----

Evaluating this produces the following result.

[source,pkl]
----
original {
  "foo"
  false
  "foo"
}
amended {
  false
  false
}
----

This behavior is consistent with the existing behavior for amending elements.
If, instead of `[0] = delete`, `amended` would include `[0] = 42`, the expected result is as follows.

[source,pkl]
----
original {
  "foo"
  false
  "foo"
}
amended {
  42
  false
  42
}
----

Hard-coded index references mean that amending can introduce stack-overflows or "cannot find key" errors.
Since elements are re-evaluated in amending, this does _not_ affect index references stemming from the object's `default`:

[source,pkl]
----
originalWithDefault = new {
  local self = this
  default = (i) -> new Dynamic { value = if (i == 0) 1 else self[i-1].value * 2 }
  new {}
  new {}
  trace(new {}) // <1>
}

amendedWithDefault = (originalWithDefault) {
  [1] = delete
}
----
<1> `trace` demonstrates re-evaluation

Evaluating this produces:

[source,pkl]
----
pkl: TRACE: new {} = new Dynamic { value = 4 } (file:///path/to/demo.pkl, line 6)
pkl: TRACE: new {} = new Dynamic { value = 2 } (file:///path/to/demo.pkl, line 6) // <1>
originalWithDefault {
  new {
    value = 1
  }
  new {
    value = 2
  }
  new {
    value = 4
  }
}
amendedWithDefault {
  new {
    value = 1
  }
  new {
    value = 2
  }
}
----
<1> The second `TRACE` demonstrates re-evaluation of `originalWithDefault[2]` in the evaluation of `amendedWithDefault`.

== Compatibility

Since this proposal introduces a new language feature, using a new - previously reserved - keyword, no existing Pkl code is affected.
There are no observable differences outside of the interpreter (in language bindings or other integrations) resulting from this proposal.

== Future directions

Discussions have been had about provenance tracing for debuggability.
In such a tool, for any object member, the provenance of the resulting value can be deduced.
Such a tool would require knowledge of the semantics of `delete`.
Considering provenance tracing would most likely require deep integration with the interpreter, it is likely most or all of this requirement can be addressed by the interpreter.

== Alternatives considered

=== Do nothing

This alternative has all the downsides stipulated in the <<Motivation>>.
It also has performance implications, because even simple deletions require `toMap()`/`toList()` and the corresponding backward transformation.
We have also observed definitions using `List` and `Map`, instead of `Listing` and `Mapping`, to avoid these transformations, thereby degrading the user experience of the template.

=== Preserving indices of elements

Instead of letting indices shift, elements could be marked as deleted "in place."
This alternative has at least one of the following two downsides:

- Indices become non-contiguous, meaning that the object's elements can no longer be consumed by iterating over `IntSeq(0, object.length() - 1)`.
- A representation for deleted elements is required for all consumers (renderers, object mappers in language bindings, etc).

The benefit of this alternative is that index references are more stable.
Although this reduces potential surprise due to non-existing elements or unwanted circular references, it is inconsistent with the existing (and remaining) surprise when an element is amended in an incompatible way.
As an example, if an element (`[i] = true`) is referred to in a condition (`if (obj[i]) 42 else 0`), amending it to a different type (`(obj) { [i] = -1 }`) causes an error when the condition is evaluated.

=== Methods

Instead of a keyword, the `Dynamic`, `Listing`, and `Mapping` classes could be given methods to allow deletion;

- `Dynamic`:
    - `deleteProperty(name: String): Dynamic`
    - `deleteEntry(key: Any): Dynamic`
    - `deleteElement(key: Int): Dynamic`
- `Mapping<out Key, out Value>`:
    - `deleteEntry(key: Any): Mapping<Key, Value>`
- `Listing<out Element>`:
    - `deleteElement(key: Int): Listing<Element>`

This takes away the need for a keyword and the associated semantics in the interpreter.
However, this alternative is less expressive/scalable, and less (notationally) idiomatic.

Without the ability to delete by member-predicate (`[[condition(this)]] = delete`), either we must define further methods (for example, `deleteEntriesWhere(condition: (Value) -> Boolean): Mapping<Key, Value>`), or resort to more cumbersome expressions as before;

[source,pkl]
----
prop = super.prop.toList().filter(condition).fold(super.prop, (acc, it) -> acc.deleteElement(it))
----

Even for "simple" deletions means property amending notation is no longer available.
Instead, an explicit expression is required:

[source,pkl]
----
prop = super.prop.deleteProperty("foo")
----

== Acknowledgements

Many thanks to Pkl's originator Peter Niederwieser and fellow maintainer Dan Chao for fruitful discussions on this topic.